{"Structs/SBSceneContainer.html#/s:11SwitchBoard16SBSceneContainerV10SceneGroupO":{"name":"SceneGroup","abstract":"<p>SceneGroups define which scenes share assets and should be loaded / cached together. Currently, this is hard coded to 4 groups as <code>enums</code> can&rsquo;t be extended or modifier. For true open sourcing, this needs to be rethought and scene groups need to be something that you can register.</p>","parent_name":"SBSceneContainer"},"Structs/SBSceneContainer.html#/s:11SwitchBoard16SBSceneContainerV9classTypeAA11SBGameSceneCmvp":{"name":"classType","abstract":"<p>The actual class of the scene. Need this to properly unarchive</p>","parent_name":"SBSceneContainer"},"Structs/SBSceneContainer.html#/s:11SwitchBoard16SBSceneContainerV4nameSSvp":{"name":"name","abstract":"<p>The name of the scene .sks file to load</p>","parent_name":"SBSceneContainer"},"Structs/SBSceneContainer.html#/s:11SwitchBoard16SBSceneContainerV10transitionSo12SKTransitionCSgvp":{"name":"transition","abstract":"<p>Default transition into this scene</p>","parent_name":"SBSceneContainer"},"Structs/SBSceneContainer.html#/s:11SwitchBoard16SBSceneContainerV11preloadableSbvp":{"name":"preloadable","abstract":"<p>Whether or not the next scene should be preloaded.</p>","parent_name":"SBSceneContainer"},"Structs/SBSceneContainer.html#/s:11SwitchBoard16SBSceneContainerV8userDataSo19NSMutableDictionaryCvp":{"name":"userData","abstract":"<p>Used to store specific data like <q>Intro</q> for type of Story scene</p>","parent_name":"SBSceneContainer"},"Structs/SBSceneContainer.html#/s:11SwitchBoard16SBSceneContainerV8categoryAC10SceneGroupOvp":{"name":"category","abstract":"<p>Which SceneGroup this scene belongs to</p>","parent_name":"SBSceneContainer"},"Structs/SBSceneContainer.html#/s:11SwitchBoard16SBSceneContainerV7atlasesSaySSGvp":{"name":"atlases","abstract":"<p>Which atlases are necessary and should be loade dby default for this scene</p>","parent_name":"SBSceneContainer"},"Structs/SBSceneContainer.html#/s:11SwitchBoard16SBSceneContainerVAcA11SBGameSceneCm9classType_SS4nameSo12SKTransitionCSg10transitionSb11preloadableAC0F5GroupO8categorySaySSG7atlasestcfc":{"name":"init(classType:name:transition:preloadable:category:atlases:)","abstract":"<p>Main initializer to set all required parameters</p>","parent_name":"SBSceneContainer"},"Structs/SBSceneContainer.html":{"name":"SBSceneContainer","abstract":"<p>Object representing each scene. By giving paramaters like transition, preloadable, etc we can have the SBSceneManager run everything dynamically.</p>"},"Protocols/SBViewDelegate.html#/s:11SwitchBoard14SBViewDelegateP6sceness10DictionaryVySSAA16SBSceneContainerVGvp":{"name":"scenes","abstract":"<p>List of all available scenes that the implementer is aware of.</p>","parent_name":"SBViewDelegate"},"Protocols/SBViewDelegate.html#/s:11SwitchBoard14SBViewDelegateP14sceneDidFinishyAA16SBSceneContainerV9nextScene_tF":{"name":"sceneDidFinish(nextScene:)","abstract":"<p>Indicate that the current scene is done, and the passed in scene should begin.</p>","parent_name":"SBViewDelegate"},"Protocols/SBViewDelegate.html#/s:11SwitchBoard14SBViewDelegateP12currentSceneAA16SBSceneContainerVSgvp":{"name":"currentScene","abstract":"<p>Handle on the current scene</p>","parent_name":"SBViewDelegate"},"Protocols/SBViewDelegate.html":{"name":"SBViewDelegate","abstract":"<p>Each scene must be aware of how to finish and start the next scene. Instead of extending the view controller and continusouly accessing that, we can create a class that implements this protocol. In this project, SBSceneManager implements this protocol, and each scene contains a reference to the scene manager. Then, each scene can just access the scene manager for informaiton on scenes, and also trigger a new scene to begin without worrying about the view.</p>"},"Classes/SBSubScene.html#/s:11SwitchBoard10SBSubSceneC9sceneNodeSo6SKNodeCSgvp":{"name":"sceneNode","abstract":"<p>Handle on the actual root node of the scene</p>","parent_name":"SBSubScene"},"Classes/SBSubScene.html#/s:11SwitchBoard10SBSubSceneC06parentD0So7SKSceneCSgXwvp":{"name":"parentScene","abstract":"<p>Each subscene will be handled by one master scene. Logic should be implemented in custom master scene</p>","parent_name":"SBSubScene"},"Classes/SBSubScene.html#/s:11SwitchBoard10SBSubSceneC9AnimationV":{"name":"Animation","abstract":"<p>Hard coded data for our hard coded custom transition</p>","parent_name":"SBSubScene"},"Classes/SBSubScene.html#/s:11SwitchBoard10SBSubSceneC10slideSoundSo8SKActionCvp":{"name":"slideSound","abstract":"<p>Sound to play when the card is animated</p>","parent_name":"SBSubScene"},"Classes/SBSubScene.html#/s:11SwitchBoard10SBSubSceneCACSS4name_tcfc":{"name":"init(name:)","abstract":"<p>For now, only set the scene name. This is so that the class can be created, but the preloading can be done whenever the caller is ready.</p>","parent_name":"SBSubScene"},"Classes/SBSubScene.html#/s:11SwitchBoard10SBSubSceneC04loadD4Fileyyyc8callback_tF":{"name":"loadSceneFile(callback:)","abstract":"<p>Preload the scene file in the background. Cache it. Assumes SKTextureAtlases were already include in SBSceneContainer for parent scene.</p>","parent_name":"SBSubScene"},"Classes/SBSubScene.html#/s:11SwitchBoard10SBSubSceneC14prepForDisplayySo7SKSceneC6parent_Sb8animatedtF":{"name":"prepForDisplay(parent:animated:)","abstract":"<p>Call this just before presenting the scene</p>","parent_name":"SBSubScene"},"Classes/SBSubScene.html#/s:11SwitchBoard10SBSubSceneC8willMoveySo6SKViewC2to_tF":{"name":"willMove(to:)","abstract":"<p>Called when subscene is initialized, but not necessarily added to screen or in view.</p>","parent_name":"SBSubScene"},"Classes/SBSubScene.html#/s:11SwitchBoard10SBSubSceneC7didMoveySo6SKViewC2to_tF":{"name":"didMove(to:)","abstract":"<p>Called after subscene has animated or appeared into view</p>","parent_name":"SBSubScene"},"Classes/SBSubScene.html#/s:11SwitchBoard10SBSubSceneC9didReturnySo6SKViewC2to_tF":{"name":"didReturn(to:)","abstract":"<p>Called after subscene has animated or appeared into view for a second time</p>","parent_name":"SBSubScene"},"Classes/SBSubScene.html#/s:11SwitchBoard10SBSubSceneC11willAnimateySo6SKViewC2to_yyc8callbacktF":{"name":"willAnimate(to:callback:)","abstract":"<p>Override if you want an intro animation to play when the scene moves or returns to view.</p>","parent_name":"SBSubScene"},"Classes/SBSubScene.html#/s:11SwitchBoard10SBSubSceneC11willAnimateySo6SKViewC4from_yyc8callbacktF":{"name":"willAnimate(from:callback:)","abstract":"<p>Override if you want an outro animation to play when the scene leaves view.</p>","parent_name":"SBSubScene"},"Classes/SBSubScene.html#/s:11SwitchBoard10SBSubSceneC7clickUpySC7CGPointV8location_tF":{"name":"clickUp(location:)","abstract":"<p>Most menus &amp; buttons are handle by their framework. This is for clicks / taps directly on the scene. Override in implementation</p>","parent_name":"SBSubScene"},"Classes/SBSubScene.html#/s:11SwitchBoard10SBSubSceneC13slideIntoViewyyF":{"name":"slideIntoView()","abstract":"<p>Move the scene into view</p>","parent_name":"SBSubScene"},"Classes/SBSubScene.html#/s:11SwitchBoard10SBSubSceneC14slideOutOfViewyyF":{"name":"slideOutOfView()","abstract":"<p>Doesn&rsquo;t actually slide out of view. Instead, waits for next subscene to slide into view, and then deletes this scene</p>","parent_name":"SBSubScene"},"Classes/SBSubScene.html#/s:11SwitchBoard10SBSubSceneC12hideFromViewyyF":{"name":"hideFromView()","abstract":"<p>Resets the scene to its animationPrepped position off screen, which both hides this scene and gets it ready for next presentation.</p>","parent_name":"SBSubScene"},"Classes/SBSceneManager.html#/s:11SwitchBoard14SBSceneManagerC12loadingSceneAA06SBGameF0CSgvp":{"name":"loadingScene","abstract":"<p>This holds on to the loading scene and keeps it permanenty cached. Hard coded to Loading.sks currently.</p>","parent_name":"SBSceneManager"},"Classes/SBSceneManager.html#/s:11SwitchBoard14SBSceneManagerC12currentSceneAA0C9ContainerVSgvp":{"name":"currentScene","abstract":"<p>Handle on the current scene</p>","parent_name":"SBSceneManager"},"Classes/SBSceneManager.html#/s:11SwitchBoard14SBSceneManagerC6sceness10DictionaryVySSAA0C9ContainerVGvp":{"name":"scenes","abstract":"<p>All scene objects that can be played.</p>","parent_name":"SBSceneManager"},"Classes/SBSceneManager.html#/s:11SwitchBoard14SBSceneManagerCACSo6SKViewC4view_tcfc":{"name":"init(view:)","abstract":"<p>Requires a view to initialize. Won&rsquo;t present anything on init. Instead, SBSceneContainers must be registered, and <code>sceneDidFinish</code> must be called with the initial scene to view.</p>","parent_name":"SBSceneManager"},"Classes/SBSceneManager.html#/s:11SwitchBoard14SBSceneManagerC13registerSceneySS3key_AA0C9ContainerV5scenetF":{"name":"registerScene(key:scene:)","abstract":"<p>Main way to add SBSceneContainers to the pool of available scenes.</p>","parent_name":"SBSceneManager"},"Classes/SBSceneManager.html#/s:11SwitchBoard14SBSceneManagerC19preloadLoadingSceneyyF":{"name":"preloadLoadingScene()","abstract":"<p>For loading to work, this has to be called after scenes are registered.","parent_name":"SBSceneManager"},"Classes/SBSceneManager.html#/s:11SwitchBoard14SBSceneManagerC14sceneDidFinishyAA0C9ContainerV9nextScene_tF":{"name":"sceneDidFinish(nextScene:)","abstract":"<p>Public facing method to play a scene. Pass in the next SBSceneContainer to get that scene to load.</p>","parent_name":"SBSceneManager"},"Classes/SBSceneManager.html#/s:11SwitchBoard14SBSceneManagerC23removeGestureRecognizeryyF":{"name":"removeGestureRecognizer()","abstract":"<p>Method to remove all gesture recognizers from the view</p>","parent_name":"SBSceneManager"},"Classes/SBGameScene.html#/s:11SwitchBoard11SBGameSceneC10WorldLayerO":{"name":"WorldLayer","abstract":"<p>Layers representing SKNodes in the scene. Currently, this is hard coded to 4 groups as <code>enums</code> can&rsquo;t be extended or modifier. For true open sourcing, this needs to be rethought and layers need to be something that you can register.</p>","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/s:11SwitchBoard11SBGameSceneC12CameraBoundsV":{"name":"CameraBounds","abstract":"<p>When constraining the camera, use this struct to adjust beyond the size of the BG</p>","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/c:@M@SwitchBoard@objc(cs)SBGameScene(py)layers":{"name":"layers","abstract":"<p>Layer nodes to hold world, UI, debug, other sub layers.</p>","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/s:11SwitchBoard11SBGameSceneC11bgSizeCacheSC6CGRectVSgvp":{"name":"bgSizeCache","abstract":"<p>Cache the accumulated frame of the BG</p>","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/s:11SwitchBoard11SBGameSceneC14sbViewDelegateAA06SBViewG0_pSgvp":{"name":"sbViewDelegate","abstract":"<p>The delegate that handles any switch board / scenemanagement related functions. Stored on","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/s:11SwitchBoard11SBGameSceneC12cameraBoundsAC06CameraF0Vvp":{"name":"cameraBounds","abstract":"<p>Handle on default camera bounds for the scene</p>","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/c:@M@SwitchBoard@objc(cs)SBGameScene(py)movementKeysEnabled":{"name":"movementKeysEnabled","abstract":"<p>Keyboard settings enabled and disabled</p>","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/c:@M@SwitchBoard@objc(cs)SBGameScene(py)previewViewController":{"name":"previewViewController","abstract":"<p>ReplayKit preview view controller used when viewing recorded content.","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/c:@M@SwitchBoard@objc(cs)SBGameScene(py)recording":{"name":"recording","abstract":"<p>Quick lookup to determine if currently recording</p>","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/c:@M@SwitchBoard@objc(cs)SBGameScene(im)buildWorldLayers":{"name":"buildWorldLayers()","abstract":"<p>This can be used for any game, but is somewhat limited since it only supports 4 layers. Constructs the 4 layers and adds them to the scene","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/s:11SwitchBoard11SBGameSceneC8addChildySo6SKNodeC4node_AC10WorldLayerO5layertF":{"name":"addChild(node:layer:)","abstract":"<p>Add a child node to one of our four hard coded layers.</p>","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/c:@M@SwitchBoard@objc(cs)SBGameScene(im)registerGestures":{"name":"registerGestures()","abstract":"<p>Call this to register pinch and pan gestures which will be tied to <q>World/bg</q> in your node tree. See <code>setCameraBounds</code>.</p>","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/c:@M@SwitchBoard@objc(cs)SBGameScene(im)removeAllGestureRecognizers":{"name":"removeAllGestureRecognizers()","abstract":"<p>Useful when unloading a scene, or when working with an SBSubscene that requires gestures, but then the next subscene does not</p>","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/s:11SwitchBoard11SBGameSceneC15setCameraBoundsyAC0fG0V06offsetG0_tF":{"name":"setCameraBounds(offsetBounds:)","abstract":"<p>Bind the camera to the size of any node in your scene named <q>bg</q> that is a child of <q>World</q>. This is automaticaly called from functions that change perspective like PinchGesture. You can also call on your own if you manually change the scale of the scene.</p>","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/c:@M@SwitchBoard@objc(cs)SBGameScene(im)removeCameraBounds":{"name":"removeCameraBounds()","abstract":"<p>Handy function to remove cameras constraints</p>","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/c:@M@SwitchBoard@objc(cs)SBGameScene(im)willAnimateTo:callback:":{"name":"willAnimate(to:callback:)","abstract":"<p>Override if you want an animation to happen before processing other scene information</p>","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/s:11SwitchBoard11SBGameSceneC11willAnimateySo6SKViewC4from_AA16SBSceneContainerV04nextD0yyc8callbacktF":{"name":"willAnimate(from:nextScene:callback:)","abstract":"<p>Override if you want an unload animation to happen for your scene before scene change happens</p>","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/c:@M@SwitchBoard@objc(cs)SBGameScene(cm)loadSceneAssetsWithCompletionHandlerWithHandler:":{"name":"loadSceneAssetsWithCompletionHandler(handler:)","abstract":"<p>Each scene should override this to preload necessary assets</p>","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/c:@M@SwitchBoard@objc(cs)SBGameScene(cm)loadAndCacheSceneAssetsWithAtlasNames:handler:":{"name":"loadAndCacheSceneAssets(atlasNames:handler:)","abstract":"<p>Scenes internally call this so that all preloading is handled by this one function","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/didFinishUpdate()":{"name":"didFinishUpdate()","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/keyUp(with:)":{"name":"keyUp(with:)","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/keyDown(with:)":{"name":"keyDown(with:)","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/scrollWheel(with:)":{"name":"scrollWheel(with:)","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/c:@M@SwitchBoard@objc(cs)SBGameScene(im)willMoveFromView:":{"name":"willMove(from:)","abstract":"<p>Called automatically and will remove nodes and actions. After this, a log line should print indicating the scene","parent_name":"SBGameScene"},"Classes/SBGameScene.html#/c:@M@SwitchBoard@objc(cs)SBGameScene(im)updateDebugLayer":{"name":"updateDebugLayer()","abstract":"<p>Call this to replace the debug layer each frame. Example use would be lines drawing a characters heading. The heading updates each frame.","parent_name":"SBGameScene"},"Classes.html#/PanGesture":{"name":"PanGesture"},"Classes.html#/c:@M@SwitchBoard@objc(cs)PinchGesture":{"name":"PinchGesture","abstract":"<p>Pinch gesture for SBGameScene&rsquo;s camera. No need to ever call publicly. Can be intilized by calling <code>registerGestures</code> on the scene.</p>"},"Classes.html#/s:11SwitchBoard7SBCacheC":{"name":"SBCache","abstract":"<p>Preloading texture atlases is often done on multiple threads, so it is tricky to pass around instances of variables. Global variables are messy and inconsistent. So, this singleton can serve as the consisten location of cache objects for this project, and will mainly be used to store a hard refernece to texture atlases.</p>"},"Classes/SBGameScene.html":{"name":"SBGameScene","abstract":"<p>Default template for a game scene. Each custom scene in a project should extend this in order to work with other items like <code><a href=\"36f8f5912051ae747ef441d6511ca4cbClasses/SBSceneManager.html\">SBSceneManager</a></code>, <code><a href=\"36f8f5912051ae747ef441d6511ca4cbClasses.html#/PanGesture\">PanGesture</a></code>, etc. Benefits of extending this class are:</p>"},"Classes/SBSceneManager.html":{"name":"SBSceneManager","abstract":"<p>This is the main class powering scene management, and should be created in the view controller. This class handles state, preloading, when to show the loading scene, communicating with the view, and caching. This class isn&rsquo;t meant to be publicly accessed. Instead, it conforms to SBViewDelegate which provides public functions that can be accessed. The reason for this is because this object holds onto cache, so we don&rsquo;t want to store a copy of it on each scene &ndash; instead, there should only be one copy that is attached to each scene as it loads.</p>"},"Classes/SBSubScene.html":{"name":"SBSubScene","abstract":"<p>Spritekit scene transitions are pretty limited, especially if you want one node to stick around (i.e.: menu, button, etc). The goal of this class is to create smaller scenes that act similar to normal scenes, but can be controlled with a custom transition.</p>"},"Classes.html":{"name":"Classes","abstract":"<p>The following classes are available globally.</p>"},"Protocols.html":{"name":"Protocols","abstract":"<p>The following protocols are available globally.</p>"},"Structs.html":{"name":"Structures","abstract":"<p>The following structures are available globally.</p>"}}